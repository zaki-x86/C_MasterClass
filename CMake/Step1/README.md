# CMake: Step 1 #

In this tutorial we will how the very fundamentals of CMake.

First, we will create a `CMakeLists.txt` file:

```terminal
user@xuser:/home/Step1$ touch CMakeLists.txt main.c
```

We then setup our basic project, which will only consist of a source file:

```terminal
Step1
    CMakeLists.txt
    main.c
```

then, we open up CMakeLists.txt and starts giving instructions to cmake on how to build our project:

```cmake
# set cmake version
cmake_minimum_required(VERSION 3.10)

# set the project name
# you can set the version number of the project
project(Tutorial VERSION 1.0)

# add the executable
add_executable(${PROJECT_NAME} main.c)
```

That's all that is needed - we can build and run our project now!
First, we need to configure our project and generate a native build system::

```terminal
user@xuser:/home/Step1$ mkdir build
user@xuser:/home/Step1$ cd build
user@xuser:/home/Step1/build$ cmake ../
```

After you're done with the configuration, cmake will respond:

```terminal
-- The C compiler identification is GNU 9.3.0
-- The CXX compiler identification is GNU 9.3.0
-- Check for working C compiler: /usr/bin/cc
-- Check for working C compiler: /usr/bin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: /abs/path/to/Step1/build
```

Now, let's build the project:
>Assuming that we've already wrote some code to `main.c`

```terminal
user@xuser:/home/Step1/build$ cmake --build
```

CMake will respond:

```terminal
Scanning dependencies of target Tutorial
[ 50%] Building C object CMakeFiles/Tutorial.dir/main.c.o
[100%] Linking C executable Tutorial
[100%] Built target Tutorial
```

Our binary file will be located inside `build/`:

```terminal
user@xuser:/home/Step1/build$ ./Tutorial --run-hello

Hello world!
```

Then, configure a header file to pass the version number to the source code:

```cmake
# set cmake version
cmake_minimum_required(VERSION 3.10)

# set the project name
# you can set the version number of the project
project(Tutorial VERSION 1.0)

# add the executable
add_executable(${PROJECT_NAME} main.c)

# configure a header file
configure_file(TutorialConfig.h.in TutorialConfig.h)
```

Since the configured file will be written into the binary tree (where our native build tool is stored), we must add that directory to the list of paths to search for include files.

```cmake
# set cmake version
cmake_minimum_required(VERSION 3.10)

# set the project name
# you can set the version number of the project
project(Tutorial VERSION 1.0)

# add the executable
add_executable(${PROJECT_NAME} main.c)

# configure a header file
configure_file(TutorialConfig.h.in TutorialConfig.h)

# include directroies
target_include_directories(${PROJECT_NAME} PUBLIC
                           "${PROJECT_BINARY_DIR}"
                           )
```

Few terms to understand here:

- `${PROJECT_NAME}`: referes to the project name.
- `{PROJECT_BINARY_DIR}` full path to where our `build/` is located.
- **Source directory**: where our `CMakeLists.txt` file exists.

Now, we need to create `TutorialConfig.h.in` in the source directory with the following contents:

```c
// the configured options and settings for Tutorial
#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@
#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@
```

Here is our `main.c`:

```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "build/TutorialConfig.h"

int main(int argc, char const *argv[])
{
    for (size_t i = 0; i < argc; i++)
    {

        if (strcmp("--run-hello", argv[i]) == 0)
        {
            printf("Hello world!\n");
        }

        if (strcmp("--version", argv[i]) == 0)
        {
            printf("Version %d.%d\n", Tutorial_VERSION_MAJOR, Tutorial_VERSION_MINOR);
        }
        
    }

    return 0;
}
```

> Notice that the header file `TutorialConfig.h` will be generated by cmake inside `build/`

Now that we have everything ready, let's build and run:

```terminal
user@xuser:/home/Step1/build$ cmake ../ && cmake --build .

-- Configuring done
-- Generating done
-- Build files have been written to: /home/Step1/build
Scanning dependencies of target Tutorial
[ 50%] Building C object CMakeFiles/Tutorial.dir/main.c.o
[100%] Linking C executable Tutorial
[100%] Built target Tutorial
```

```terminal
user@xuser:/home/Step1/build$ /Tutorial --version

Version 1.0
```

You might as well specify the C standard to be applied through the project, by adding these lines at the end of `CMakeLists.txt`:

```cmake
# specify the C standard
set(CMAKE_C_STANDARD 11)
set(CMAKE_C_STANDARD_REQUIRED True)
```

Then rebuild:

```terminal
user@xuser:/home/Step1/build$ cmake ../ && cmake --build .

-- Configuring done
-- Generating done
-- Build files have been written to: /home/Step1/build
[100%] Built target Tutorial
```
